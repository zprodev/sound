{"version":3,"file":"supported.mjs","sources":["../../src/utils/supported.ts"],"sourcesContent":["type ExtensionMap = Record<string, boolean>;\n\n/**\n * The list of extensions that can be played. This is the preferred order of playback.\n * If you want to priority the order of playback, you can use this array to do so.\n * @readonly\n * @memberof utils\n */\nconst extensions: string[] = [\n    'ogg',\n    'oga',\n    'opus',\n    'm4a',\n    'mp3',\n    'mpeg',\n    'wav',\n    'aiff',\n    'wma',\n    'mid',\n    'caf',\n];\n\nconst mimes: string[] = [\n    'audio/mpeg',\n];\n\n/**\n * The list of browser supported audio formats.\n * @readonly\n * @memberof utils\n * @property {boolean} mp3 - `true` if file-type is supported\n * @property {boolean} ogg - `true` if file-type is supported\n * @property {boolean} oga - `true` if file-type is supported\n * @property {boolean} opus - `true` if file-type is supported\n * @property {boolean} mpeg - `true` if file-type is supported\n * @property {boolean} wav - `true` if file-type is supported\n * @property {boolean} aiff - `true` if file-type is supported\n * @property {boolean} wma - `true` if file-type is supported\n * @property {boolean} mid - `true` if file-type is supported\n * @property {boolean} caf - `true` if file-type is supported. Note that for this we check if the\n *                             'opus' codec is supported inside the caf container.\n */\nconst supported: ExtensionMap = {};\n\n/**\n * Function to validate file type formats. This is called when the library initializes, but can\n * be called again if you need to recognize a format not listed in `utils.extensions` at\n * initialization.\n * @memberof utils\n * @param typeOverrides - - Dictionary of type overrides (inputs for\n *                                 AudioElement.canPlayType()), keyed by extension from the\n *                                 utils.extensions array.\n */\nfunction validateFormats(typeOverrides?: Record<string, string>): void\n{\n    const overrides: Record<string, string> = {\n        m4a: 'audio/mp4',\n        oga: 'audio/ogg',\n        opus: 'audio/ogg; codecs=\"opus\"',\n        caf: 'audio/x-caf; codecs=\"opus\"', ...(typeOverrides || {}) };\n    const audio = document.createElement('audio');\n    const formats: ExtensionMap = {};\n    const no = /^no$/;\n\n    extensions.forEach((ext) =>\n    {\n        const canByExt = audio.canPlayType(`audio/${ext}`).replace(no, '');\n        const canByType = overrides[ext] ? audio.canPlayType(overrides[ext]).replace(no, '') : '';\n\n        formats[ext] = !!canByExt || !!canByType;\n    });\n    Object.assign(supported, formats);\n}\n\n// initialize supported\nvalidateFormats();\n\nexport {\n    validateFormats,\n    supported,\n    extensions,\n    mimes,\n};\n"],"names":[],"mappings":"AAQA,MAAM,UAAuB,GAAA;AAAA,EACzB,KAAA;AAAA,EACA,KAAA;AAAA,EACA,MAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AAAA,EACA,MAAA;AAAA,EACA,KAAA;AAAA,EACA,MAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AACJ,EAAA;AAEA,MAAM,KAAkB,GAAA;AAAA,EACpB,YAAA;AACJ,EAAA;AAkBA,MAAM,YAA0B,GAAC;AAWjC,SAAS,gBAAgB,aACzB,EAAA;AACI,EAAA,MAAM,SAAoC,GAAA;AAAA,IACtC,GAAK,EAAA,WAAA;AAAA,IACL,GAAK,EAAA,WAAA;AAAA,IACL,IAAM,EAAA,0BAAA;AAAA,IACN,GAAK,EAAA,4BAAA;AAAA,IAA8B,GAAI,iBAAiB,EAAC;AAAA,GAAG,CAAA;AAChE,EAAM,MAAA,KAAA,GAAQ,QAAS,CAAA,aAAA,CAAc,OAAO,CAAA,CAAA;AAC5C,EAAA,MAAM,UAAwB,EAAC,CAAA;AAC/B,EAAA,MAAM,EAAK,GAAA,MAAA,CAAA;AAEX,EAAW,UAAA,CAAA,OAAA,CAAQ,CAAC,GACpB,KAAA;AACI,IAAM,MAAA,QAAA,GAAW,MAAM,WAAY,CAAA,CAAA,MAAA,EAAS,KAAK,CAAE,CAAA,OAAA,CAAQ,IAAI,EAAE,CAAA,CAAA;AACjE,IAAA,MAAM,SAAY,GAAA,SAAA,CAAU,GAAG,CAAA,GAAI,KAAM,CAAA,WAAA,CAAY,SAAU,CAAA,GAAG,CAAC,CAAA,CAAE,OAAQ,CAAA,EAAA,EAAI,EAAE,CAAI,GAAA,EAAA,CAAA;AAEvF,IAAA,OAAA,CAAQ,GAAG,CAAI,GAAA,CAAC,CAAC,QAAA,IAAY,CAAC,CAAC,SAAA,CAAA;AAAA,GAClC,CAAA,CAAA;AACD,EAAO,MAAA,CAAA,MAAA,CAAO,WAAW,OAAO,CAAA,CAAA;AACpC,CAAA;AAGA,eAAgB,EAAA;;;;"}